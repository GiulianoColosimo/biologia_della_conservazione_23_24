{
  "hash": "20f6f2b5c83302d0507e18ba1abbabcb",
  "result": {
    "markdown": "---\ntitle: \"Biologia della Conservazione\"\nsubtitle: \"Class 9 - Manuscript discussion-Genetic Drift/Effective Population Size/Coalescence\"\ndate: \"2024-04-18\"\nfooter:  \"[Biologia della conservazione 23/24 - Giuliano Colosimo, PhD](https://giulianocolosimo.github.io/biologia_della_conservazione_23_24/)\"\nlogo: ../../figures/Tor-Vergata_logo_cmyk.png\nformat: \n  revealjs:\n    width: 1600\n    height: 900 \n    theme: slides.scss\n    multiplex: true\n    transition: fade\n    slide-number: true\n    preview-links: true\n    chalkboard: \n      boardmarker-width: 5\neditor: visual\nfrom: markdown+emoji\nexecute:\n  freeze: auto\neditor_options: \n  chunk_output_type: console\nbibliography: /Users/giulianocolosimo/Library/CloudStorage/ProtonDrive-giuliano.colosimo@protonmail.com/manuscripts/literature/bibtex/comprehensive_database.bib\ncsl: /Users/giulianocolosimo/Library/CloudStorage/ProtonDrive-giuliano.colosimo@protonmail.com/manuscripts/literature/bibtex/apa_5th_edition.csl\ncitation_package: biblatex\ncitecolor: \"red\"\n---\n\n\n\n\n| Student | Title                                                                                                                                 |\n|--------------------------------|----------------------------------------|\n| FALVO   | [Developing gene drive technologies to eradicate invasive rodents from islands](https://drive.proton.me/urls/9WVQGE6J5M#GEndO0gEvVJq) |\n| D'ALESSANDRO | [Population genetic analysis of the recently rediscovered hula painted frog (*Latonia nigriventer*) reveals high genetic diversity and low inbreeding](https://drive.proton.me/urls/HQMV65ETB0#vB21xDrPrAXN) |\n\n---\n\n## Topics\n\n::: columns\n::: {.column width=\"50%\"}\n1.  [Introduction to conservation biology]{style=\"color: green;\"}\n2.  [Biodiversity]{style=\"color: green;\"}\n3.  [Biodiversity and extinctions]{style=\"color: green;\"}\n4.  [Populations]{style=\"color: green;\"}\n5.  [Basics of conservation genetics]{style=\"color: green;\"}\n6.  [Genetic drift]{style=\"color: orange;\"}\n7.  [Effective population size]{style=\"color: orange;\"}\n8.  [Inbreeding depression]{style=\"color: blue;\"}\n9.  [Population structure]{style=\"color: blue;\"}\n10. [Hybridization]{style=\"color: blue;\"}\n11. [Applying genetic information to conservation]{style=\"color: blue;\"}\n:::\n\n::: {.column width=\"50%\"}\n12. [Managing genetic diversity in captive populations]{style=\"color: blue;\"}\n13. [Managing genetic diversity in the wild]{style=\"color: blue;\"}\n14. [Population viability analysis]{style=\"color: blue;\"}\n15. [Invasive species]{style=\"color: blue;\"}\n16. [CITES and trade regulations of endangered species]{style=\"color: blue;\"}\n17. [Conservation and climate change]{style=\"color: blue;\"}\n18. [Future climate impacts]{style=\"color: blue;\"}\n19. [Conservation economics]{style=\"color: blue;\"}\n20. [Conservation technology]{style=\"color: blue;\"}\n:::\n:::\n\n------------------------------------------------------------------------\n\n### Coalescence simulation function\n\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\n# Funzione per la simulazione del processo di coalescenza\n\ncoalesc_sim <- function(t, N) { \n  \n  # t = durata della simulazione in generazioni \n  # N = dimensione effettiva della popolazione\n  \n  # vettore per indicizzazione delle generazioni\n  g  <-  1:t        \n  \n  # WF pop quindi n è costante in tutte le generazioni ed uguale a N   \n  # possiamo modificare questa parte per fare simulazioni con N variabile\n  n  <-  rep(N, t) \n  \n  # lista di vettori di lunghezza t\n  # ogni vettore i-esimo rappresenta l’identità \n  # del membro della generazione (i-1)-esima che è l’ancestore \n  # di ciascun membro della generazione i-esima.\n  p  <-  vector(mode = \"list\", length = t) \n  \n  # la prima generazione è da 1:N che rappresentano anche l'ID dell'individuo\n  p[[1]]  <-  1:N \n  \n  # il ciclo viene ripetuto per ciascuna generazione da 2 a t\n  # la prima generazione l'abbiamo già formata quindi non c'è bisogno \n  for(i in 2:length(g)){ \n    p[[i]]  <-  sort(sample(1:n[i-1],    # funzione sample per il campionamento casuale dalla gen i-1\n                            size = n[i], # dimensione del campione\n                            replace = T) # \n                     ) \n  }\n  \n  # questo serve solo per dire a R che la funzione deve sputare fuori qualcosa, \n  # in particolare l’elenco delle generazioni da 1 a t (g), \n  # la dimensione effettiva per ciascuna generazione (n), \n  # e la lista degli antenati per ciascuna generazione (p)...\n  return(list(g = g, n = n, p = p)) \n  \n}\n\nt <- 25\nN <- 13\nsim <- coalesc_sim(t, N)\nsim\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$g\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n\n$n\n [1] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13\n\n$p\n$p[[1]]\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13\n\n$p[[2]]\n [1]  1  3  3  4  6  7  9  9 12 12 12 12 13\n\n$p[[3]]\n [1]  3  3  4  4  5  5  6  6  6  8  8  9 10\n\n$p[[4]]\n [1]  2  4  4  4  4  5  6  9  9 10 10 10 13\n\n$p[[5]]\n [1]  1  1  2  3  6  8  8  8  9 10 10 11 12\n\n$p[[6]]\n [1]  1  2  3  5  6  8  9  9  9 10 10 12 12\n\n$p[[7]]\n [1]  2  3  3  4  5  6  6  8  9 10 11 13 13\n\n$p[[8]]\n [1]  1  3  3  4  5  6  7  7  7  8 10 11 13\n\n$p[[9]]\n [1]  3  4  4  6  6  6  7  8  8  8  9 11 13\n\n$p[[10]]\n [1]  2  2  5  6  7  8  9  9  9  9 10 11 12\n\n$p[[11]]\n [1]  1  2  3  3  5  5  7  8  9 10 11 11 13\n\n$p[[12]]\n [1]  1  1  3  4  4  6  6  7  8  8 11 11 13\n\n$p[[13]]\n [1]  1  3  3  3  5  6  6  9 10 10 10 10 11\n\n$p[[14]]\n [1]  3  3  3  4  7  7  7  7 11 12 12 12 13\n\n$p[[15]]\n [1]  1  1  3  3  3  4  4  4  5  7  7 10 12\n\n$p[[16]]\n [1]  1  1  2  4  5  6  6  6  9  9 10 10 11\n\n$p[[17]]\n [1]  1  2  2  2  4  5  7  9  9 10 11 12 12\n\n$p[[18]]\n [1]  2  3  3  5  5  6  7  7  8  9 10 11 13\n\n$p[[19]]\n [1]  2  4  4  8  9  9  9 10 11 11 12 12 13\n\n$p[[20]]\n [1]  1  1  1  2  2  5  7 11 12 12 12 13 13\n\n$p[[21]]\n [1]  1  2  3  4  5  5  9 10 11 12 12 12 13\n\n$p[[22]]\n [1]  2  2  2  3  4  4  6  8  9 10 12 13 13\n\n$p[[23]]\n [1]  1  3  5  5  6  6  7  8 11 11 12 12 13\n\n$p[[24]]\n [1]  4  5  5  6  6  7  8  8  9 11 11 11 12\n\n$p[[25]]\n [1]  1  2  2  3  4  4  5  5  6  8  9 10 11\n```\n:::\n:::\n\n\n---\n\n### Coalescence simulation graphic function\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\n# Funzione per la produzione di un grafico a partire dai dati creati\n# dalla simulazione di una processo di coalescenza\n\ncoalescent_plot = function(sim, \n                           cex.dots = 1, \n                           cex.lab = 1, \n                           col.dots = NULL, \n                           cex.ylab = 1, \n                           steps = NULL,\n                           ...) {\n  \n  p <- sim$p\n  n <- sim$n\n  g <- sim$g\n  t <- length(sim$g)\n  \n  # con queste righe di codice assegniamo il colore degli individui della \n  # generazione i-esima in modo che sia uguale a quello della generazione (i-esima)-1, ovvero\n  # dei loro ancestori. Da notare che a meno che i colori non vengano specificati \n  # in maniera attiva, R userà solo 8 colori di base e se la nostra popolazione\n  # ha più di 8 individui riciclerà i colori ogni 8 individui\n  cols <-  sim$p\n  for(i in 2:(length(cols)-1)){\n    cols[[i+1]] = cols[[i]][sim$p[[i+1]]]\n    }\n  \n  # al momento non si possono specificare dei colori ad-hoc per ogni singolo individuo\n  # ma se un colore vieni specificato come argomento della funzione tutti i pallini \n  # avranno quel colore\n  if(is.character(col.dots)){\n    cols = lapply(1:length(n), function(i){rep(col.dots, n[i])})\n  }\n  \n  \n  if(is.null(steps)){\n    steps = t\n  }\n  \n  # print di un plot vuoto\n  plot(0,0, type = \"n\",\n       xlim = c(1, max(n)),\n       ylim = c(1, t),\n       xaxt = \"n\",\n       yaxt = \"n\",\n       bty = \"n\",\n       xlab = \"\",\n       ylab = \"\", cex.lab = cex.lab, ...)\n  text(x = -.5, y = t, labels = expression('Present (t'[i]*')'), adj = 1)\n  text(x = -.5, y = 1, labels = expression('Past (t'[0]*')'), adj = 1)\n  \n  # i segmenti sono disegnati da i-esima generazione a (i-esima)-1 generazione\n  # per essere piu precisi sono sono disegnati da (i-esima+1) a i-esima\n  if(steps > 1){\n    for(i in 1:(steps-1)){\n      segments(x0 = 1:n[i+1],\n               x1 = p[[i+1]],\n               y0 = i+1,\n               y1 = i,\n               ...)\t\t\n    }\n  }\n  \n  # i pallini rappresentanti gli individui vengono disegnati per ultimi \n  # sopra i segmenti\n  for(i in 1:steps){\n    points(1:n[i],\n           rep(i, n[i]),\n           cex = cex.dots,\n           bg = cols[[i]],\n           pch = 21)\t\t\n  }\n}\n\ncoalescent_plot(sim,  \n                cex.dots = 2, \n                col.dots = \"orange\",\n                asp = 1)\n```\n\n::: {.cell-output-display}\n![](class_9_files/figure-revealjs/function2-1.png){width=960}\n:::\n:::\n\n\n---\n\n### Coalescence simulation graphic function\n\n\n::: {.cell output-location='column'}\n\n```{.r .cell-code}\ncoalescent_plot(sim,  \n                cex.dots = 2, \n                col.dots = \"orange\",\n                asp = 1)\n\n# questa funzione ci aiuta a visualizzare il \"percorso\" di uno degli aplotipi\n# nel passato fino all'ancesotre iniziale\n# l'aplotipo da visualizzare lo individuiamo noi con il parametro k\n# se facciamo correre la funzione su due aplotipi possiamo individuare l'ancestore comune\n\nancestral_marker <- function(sim, k,\n                     anc.col = \"black\",\n                     anc.lwd = 2,\n                     cex.dots = 1){\n  \n  # codice originale a cura del prof. Gratton\n  \n  p = sim$p\n  n = sim$n\n  g = sim$g\n  t = length(sim$g)\n  \n  middle = max(n)/2    \n  mm_0 = sapply(1:(t-1), function(i){middle - n[i]/2})\n  mm_1 = sapply(1:(t-1), function(i){middle - n[i+1]/2})\n  \n  for(i in k){\n    ks = rep(NA, t)\n    ks[t] = i\n    for(j in (t-1):1){\n      ks[j] = p[[j+1]][ks[j+1]]\n    }\n  }\n  \n  segments(x0 = ks[1:(t-1)] + mm_0, x1 = ks[2:t] + mm_1, y0 = g[1:(t-1)], y1 = g[2:t], col = anc.col, lwd = anc.lwd)\n  points(x = ks + c(mm_0, mm_1[length(mm_1)]), y = 1:t, cex = cex.dots, bg = anc.col, pch = 21)\n      \n}\n\nancestral_marker(sim, 13, cex.dots = 2)\n\nancestral_marker(sim, 3, cex.dots = 2)\n```\n\n::: {.cell-output-display}\n![](class_9_files/figure-revealjs/function3b-1.png){width=960}\n:::\n:::\n\n\n\n## References",
    "supporting": [
      "class_9_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}